int ad_ioctl(struct inode *indoe, struct file *file, unsigned int ioctl_num, unsigned long ioctl_param)
{
//zmienne
int pid;
int i,j;
int channels = 0;
int new = 1;
unsigned char pom[USB_AD_CHANNELS_NUM];

//sprawdzenie czy to nasz
if (access_ok(VERIFY_READ,(char *)ioctl_param,2 * sizeof(int) ) == 0)
        return -EFAULT;  
if (((int*)ioctl_param)[0] != USB_AD_IOCTL_MAGIC_NUMBER) {
        printk("<1>USB_AD: Nie nasz IOCTL\n");
        return -EIO;
        }
pid = ((int*)ioctl_param)[1];
//dorwanie klienta {czy tworzymy nowego czy staremu zmieniamy parametry probkowania}
for (i = 0;i < USB_AD_MAX_CLIENTS_NUM;i++)
        if(gpClients_array[i] != NULL)
                if (gpClients_array[i]->pid == pid) {
                        new = 0;
                        break;
                        }
//swybranie tego co mamy klientowi zrobic
switch (ioctl_num) {
        case IOCTL_SET_PARAMS:
        //czy wskaxnik jest ok
                if (access_ok(VERIFY_READ,(char *)ioctl_param,(4+USB_AD_CHANNELS_NUM) * sizeof(int)) == 0) 
                        return -EFAULT;
                for (j = 0;j < USB_AD_CHANNELS_NUM;j++)
                        pom[j] = ((int *)ioctl_param)[j + 4];
                if (new == 1) {
                        for (j = 0;j < USB_AD_MAX_CLIENTS_NUM; j++)
                                if (gpClients_array[j] == NULL)
                                        break;
                        if(j == USB_AD_MAX_CLIENTS_NUM - 1)
                                return -EFAULT;
                        gpClients_array[j] = kmalloc(sizeof(Client),GFP_KERNEL);
                        if (gpClients_array[j] == NULL) 
                                return -EFAULT;
                        if (init_client(gpClients_array[j],pid,((int *)ioctl_param)[3],((int *)ioctl_param)[4],pom) < 0)
                                return -EFAULT;        
                        }
                        else {
                        //Wstepna implementacja: Zabijamy go i tworzymy nowego 
                        remove_client(gpClients_array[i]);
                        //tworzenie nowego
                        gpClients_array[i] = kmalloc(sizeof(Client),GFP_KERNEL);
                        if (gpClients_array[i] == NULL) 
                                return -EFAULT;
                        if (init_client(gpClients_array[i],pid,((int *)ioctl_param)[3],((int *)ioctl_param)[4],pom) < 0)
                                return -EFAULT;   
                        }
                break;
        case IOCTL_GET_DATA:
        //czy wskaxnik jest ok
                if (new == 1) {
                        printk("<1>USB_AD: Najpierw trzeba sie przedstawic sterownikowi, potem pobierac dane");
                        return -EFAULT;
                        }
                for (j = 0;j < USB_AD_CHANNELS_NUM;j++)
                        if (gpClients_array[i]->channels[j] == 1)
                                channels++;
                if (access_ok(VERIFY_WRITE,(char *)ioctl_param,gpClients_array[i]->buffer_size*channels) == 0 )
                        return -EFAULT;
                //sprawdzic czy jest co wyslac jak nie to zawiesic
                wait_event(gpClients_array[i]->queue,(gpClients_array[i]->buffer_full_number == 1 || gpClients_array[i]->buffer_full_number == 2));
                //wait_event(queue,(gpClients_array[i]->buffer_full_number == 1 || gpClients_array[i]->buffer_full_number == 2));
                //sprawdzenie ktory bufor mamy wyslac	
                switch (gpClients_array[i]->buffer_full_number) {
                        case 1:
                                return copy_to_user(gpClients_array[i]->first_buf.buf,(char *)ioctl_param,gpClients_array[i]->first_buf.size);
                        case 2:
                                return copy_to_user(gpClients_array[i]->second_buf.buf,(char *)ioctl_param,gpClients_array[i]->second_buf.size);
                        }
                break;
        default: printk("<1>USB_AD: TO NIE MOZE SIE ZDAZYC (AKURAT)\n");
        }


return 0;
}


